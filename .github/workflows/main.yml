name: Provision and Deploy (OIDC)

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  run-all:
    runs-on: windows-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure login using OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}  
          enable-AzPSSession: true

      - name: Run provisioning script
        shell: pwsh
        run: |
          cd scripts
          ./provision.ps1
          if (-not (Test-Path "outputs.json")) {
            Write-Error "outputs.json not found, provisioning failed"
            exit 1
          }

      - name: Parse outputs.json
        id: parse
        shell: pwsh
        run: |
          $outputs = Get-Content scripts/outputs.json | ConvertFrom-Json
          $FN_NAME = $outputs.functionApp.name
          $KV_NAME = $outputs.keyVault.name
          $RG_NAME = $outputs.resourceGroup
          if ([string]::IsNullOrEmpty($FN_NAME)) { Write-Error "Missing functionApp.name in outputs.json"; exit 1 }
          if ([string]::IsNullOrEmpty($KV_NAME)) { Write-Error "Missing keyVault.name in outputs.json"; exit 1 }
          if ([string]::IsNullOrEmpty($RG_NAME)) { Write-Error "Missing resourceGroup in outputs.json"; exit 1 }
          "fn_name=$FN_NAME" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "kv_name=$KV_NAME" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "rg_name=$RG_NAME" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Build function app
        shell: pwsh
        run: |
          cd FunctionApp/FunctionAppACS/FunctionAppACS
          dotnet restore
          dotnet clean
          dotnet build -c Release
          dotnet publish -c Release -o ../../../publish

      - name: Verify publish output
        shell: pwsh
        run: |
          Write-Host "Checking published files..."
          Get-ChildItem -Path publish -Recurse | Select-Object FullName | Format-Table
          
          if (Test-Path "publish/FunctionAppACS.dll") {
            Write-Host "✓ Function DLL found" -ForegroundColor Green
          } else {
            Write-Error "Function DLL not found in publish folder"
          }

      - name: Package function zip
        shell: pwsh
        run: |
          cd publish
          Compress-Archive -Path * -DestinationPath ../deploy.zip -Force
          cd ..
          Write-Host "Deploy package size: $((Get-Item deploy.zip).Length / 1MB) MB"

      - name: Deploy zip to Function App
        shell: pwsh
        run: |
          $FN = "${{ steps.parse.outputs.fn_name }}"
          $RG = "${{ steps.parse.outputs.rg_name }}"
          az functionapp deployment source config-zip -g $RG -n $FN --src ./deploy.zip

      - name: Configure app settings (KEY_VAULT_URI and CALLBACK_URI)
        shell: pwsh
        run: |
          $FN = "${{ steps.parse.outputs.fn_name }}"
          $KV = "${{ steps.parse.outputs.kv_name }}"
          $RG = "${{ steps.parse.outputs.rg_name }}"
          $KV_URI = "https://$KV.vault.azure.net/"
          $CALLBACK = "https://$FN.azurewebsites.net/api/CallEvents"
          
          Write-Host "Setting application configuration..."
          az functionapp config appsettings set `
            -g $RG `
            -n $FN `
            --settings `
              KEY_VAULT_URI="$KV_URI" `
              CALLBACK_URI="$CALLBACK" `
              FUNCTIONS_WORKER_RUNTIME="dotnet-isolated"
          
          Write-Host "✓ Application settings configured"

      - name: Verify Key Vault access and secret
        shell: pwsh
        continue-on-error: true
        run: |
          $FN = "${{ steps.parse.outputs.fn_name }}"
          $KV = "${{ steps.parse.outputs.kv_name }}"
          $RG = "${{ steps.parse.outputs.rg_name }}"
          
          Write-Host "Checking Key Vault secret and permissions..."
          
          # Check if secret exists
          $secretExists = az keyvault secret show --vault-name $KV --name AcsConnectionString --query value -o tsv 2>$null
          if ($secretExists) {
            Write-Host "✓ AcsConnectionString secret exists in Key Vault" -ForegroundColor Green
          } else {
            Write-Warning "AcsConnectionString secret not found in Key Vault"
          }
          
          # Get Function App principal ID
          $principalId = az functionapp identity show -g $RG -n $FN --query principalId -o tsv
          Write-Host "Function App Principal ID: $principalId"
          
          # Check role assignment
          $vaultId = az keyvault show -n $KV -g $RG --query id -o tsv
          $roleAssignment = az role assignment list --assignee $principalId --scope $vaultId --role "Key Vault Secrets Officer" -o json | ConvertFrom-Json
          
          if ($roleAssignment -and $roleAssignment.Count -gt 0) {
            Write-Host "✓ Function App has Key Vault Secrets Officer role" -ForegroundColor Green
          } else {
            Write-Warning "Function App does not have Key Vault Secrets Officer role"
            Write-Host "Attempting to assign role..."
            try {
              az role assignment create --assignee-object-id $principalId --assignee-principal-type ServicePrincipal --role "Key Vault Secrets Officer" --scope $vaultId
              Write-Host "✓ Role assigned successfully" -ForegroundColor Green
            } catch {
              Write-Warning "Could not assign role: $_"
            }
          }

      - name: Restart Function App and wait for it to be ready
        shell: pwsh
        run: |
          $FN = "${{ steps.parse.outputs.fn_name }}"
          $RG = "${{ steps.parse.outputs.rg_name }}"
          
          Write-Host "Restarting Function App to apply all changes..."
          az functionapp restart -g $RG -n $FN
          
          Write-Host "Waiting for Function App to start (60 seconds)..."
          Start-Sleep -Seconds 60
          
          # Check function app status
          Write-Host "Checking Function App status..."
          $status = az functionapp show -g $RG -n $FN --query state -o tsv
          Write-Host "Function App state: $status"
          
          # Try to ping the function app
          $appUrl = "https://$FN.azurewebsites.net"
          Write-Host "Checking if Function App is responding at $appUrl..."
          try {
            $response = Invoke-WebRequest -Uri $appUrl -Method GET -TimeoutSec 10 -SkipHttpErrorCheck
            Write-Host "Function App responded with status: $($response.StatusCode)"
          } catch {
            Write-Host "Function App health check: $_"
          }

      - name: Fetch function key and smoke test
        shell: pwsh
        continue-on-error: true
        run: |
          $FN = "${{ steps.parse.outputs.fn_name }}"
          $RG = "${{ steps.parse.outputs.rg_name }}"
          
          # Retry logic for getting function keys
          $maxRetries = 6
          $retryCount = 0
          $KEY = $null
          
          while ($retryCount -lt $maxRetries -and [string]::IsNullOrEmpty($KEY)) {
            try {
              Write-Host "Attempting to fetch function keys (attempt $($retryCount + 1)/$maxRetries)..."
              $KEY_JSON = az functionapp function keys list -g $RG -n $FN --function-name MakeCall -o json 2>&1
              if ($LASTEXITCODE -eq 0) {
                $KEY_OBJ = $KEY_JSON | ConvertFrom-Json
                $KEY = $KEY_OBJ.default
                if (-not [string]::IsNullOrEmpty($KEY)) {
                  Write-Host "✓ Successfully retrieved function key"
                  break
                }
              } else {
                Write-Host "Azure CLI returned non-zero exit code: $LASTEXITCODE"
              }
            } catch {
              Write-Host "Attempt failed: $_"
            }
            
            $retryCount++
            if ($retryCount -lt $maxRetries) {
              Write-Host "Waiting 20 seconds before retry..."
              Start-Sleep -Seconds 20
            }
          }
          
          if ([string]::IsNullOrEmpty($KEY)) {
            Write-Warning "Could not fetch function key after $maxRetries attempts."
            Write-Host ""
            Write-Host "=== Manual Testing Instructions ===" -ForegroundColor Cyan
            Write-Host "The function app has been deployed but keys are not yet available."
            Write-Host "Wait a few minutes and test manually:" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "1. Get the function key:" -ForegroundColor White
            Write-Host "   az functionapp function keys list -g $RG -n $FN --function-name MakeCall" -ForegroundColor Gray
            Write-Host ""
            Write-Host "2. Test the function:" -ForegroundColor White
            Write-Host "   Invoke-RestMethod -Uri 'https://$FN.azurewebsites.net/api/MakeCall?code=YOUR_KEY' -Method POST -Body '{\"to\":\"+1234567890\",\"from\":\"+0987654321\"}' -ContentType 'application/json'" -ForegroundColor Gray
            Write-Host ""
            exit 0
          }
          
          $URL = "https://$FN.azurewebsites.net/api/MakeCall?code=$KEY"
          Write-Host ""
          Write-Host "=== Smoke Test ===" -ForegroundColor Cyan
          Write-Host "Testing endpoint: $URL"
          $body = @{
            to = "+441234567890"
            from = "+15551234567"
          } | ConvertTo-Json
          
          try {
            $response = Invoke-RestMethod -Uri $URL -Method POST -Body $body -ContentType "application/json" -ErrorAction Stop
            Write-Host "✓ Smoke test completed successfully" -ForegroundColor Green
            Write-Host "Response: $response"
          } catch {
            $errorMsg = $_.Exception.Message
            if ($errorMsg -like "*AcsConnectionString missing*") {
              Write-Host ""
              Write-Warning "Function cannot access ACS connection string from Key Vault"
              Write-Host "This usually resolves after a few minutes as permissions propagate."
              Write-Host ""
              Write-Host "To verify manually:" -ForegroundColor Cyan
              Write-Host "1. Wait 2-3 minutes for Azure RBAC to propagate"
              Write-Host "2. Test again with the same command"
              Write-Host "3. If still failing, check:"
              Write-Host "   - Key Vault secret exists: az keyvault secret show --vault-name $KV --name AcsConnectionString"
              Write-Host "   - Function has role: az role assignment list --assignee <PRINCIPAL_ID> --scope <VAULT_ID>"
            } elseif ($errorMsg -like "*403*" -or $errorMsg -like "*Forbidden*") {
              Write-Warning "Key Vault access denied - RBAC permissions may still be propagating"
            } else {
              Write-Host "Smoke test result: $errorMsg" -ForegroundColor Yellow
              Write-Host "(Expected if phone numbers are not configured in ACS)"
            }
          }
